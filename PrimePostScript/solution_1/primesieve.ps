% limit primesieve -> sieve
/primesieve {
    dup 1 le {
        pop () % return empty sieve if limit â‰¤ 1
    } {
        1 add 2 idiv string % sieve (only odd numbers)
        dup 0 1 put % mark 1 as non-prime
        0 % current sieve position

        1 index { % iterate over sieve
            0 eq { % skip non-primes
                dup 2 mul 1 add % calculate current prime from sieve position
                dup dup mul 1 add 2 idiv 1 sub % from: position of squared prime
                3 index length 1 sub % to: sieve length - 1

                2 copy gt { pop pop pop exit } if % break condition: from > to

                % iterate over indices corresponding to every second multiple
                % of the current prime number, starting from its square
                3 -1 roll exch % rearrange stack for loop: from-step-to
                {
                    2 index % grab sieve
                    exch 1 put % mark as non-prime
                } for
            } if
            1 add % track sieve position
        } forall

        pop % remove sieve position from the stack

        % 2 is a special case: mark first position as prime so that the count is correct
        dup 0 0 put
    } ifelse
} def

% sieve callback iterprimes
/iterprimes {
    1 index length 1 ge { dup 2 exch exec } if
    1  1  3 index length 1 sub {
        dup
        3 index exch get
        0 eq {
            1 add 2 mul 1 sub
            1 index exec
        } { pop } ifelse
    } for
    pop pop
} def

% limit countprimes -> count
/countprimes {
    primesieve
    0 exch { 1 exch sub add } forall
} def

% limit listprimes
/listprimes {
    primesieve
    { = }
    iterprimes
} def
